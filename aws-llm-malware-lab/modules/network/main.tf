###############################################################################
# Network Module – Isolated VPC, NAT Instance, NACLs, DNS Firewall
###############################################################################

data "aws_caller_identity" "current" {}

locals {
  name_prefix = "malware-lab-${var.environment}"
}

# ─── VPC ─────────────────────────────────────────────────────────────────────

resource "aws_vpc" "lab" {
  cidr_block           = var.vpc_cidr
  enable_dns_support   = true   # required for VPC endpoints
  enable_dns_hostnames = true

  tags = {
    Name        = "${local.name_prefix}-vpc"
    Environment = "MalwareLab"
  }
}

# ─── Internet Gateway (public subnet only) ───────────────────────────────────

resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.lab.id
  tags   = { Name = "${local.name_prefix}-igw" }
}

# ─── Subnets ─────────────────────────────────────────────────────────────────

resource "aws_subnet" "public" {
  vpc_id                  = aws_vpc.lab.id
  cidr_block              = var.public_subnet_cidr
  availability_zone       = var.availability_zone
  map_public_ip_on_launch = false

  tags = {
    Name        = "${local.name_prefix}-public"
    Environment = "MalwareLab"
    Tier        = "egress"
  }
}

resource "aws_subnet" "private" {
  vpc_id                  = aws_vpc.lab.id
  cidr_block              = var.private_subnet_cidr
  availability_zone       = var.availability_zone
  map_public_ip_on_launch = false

  tags = {
    Name        = "${local.name_prefix}-private"
    Environment = "MalwareLab"
    Tier        = "detonation"
  }
}

# ─── Route Tables ────────────────────────────────────────────────────────────

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.lab.id
  tags   = { Name = "${local.name_prefix}-public-rt" }
}

resource "aws_route" "public_igw" {
  route_table_id         = aws_route_table.public.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_internet_gateway.igw.id
}

resource "aws_route_table_association" "public" {
  subnet_id      = aws_subnet.public.id
  route_table_id = aws_route_table.public.id
}

resource "aws_route_table" "private" {
  vpc_id = aws_vpc.lab.id
  tags   = { Name = "${local.name_prefix}-private-rt" }
}

resource "aws_route" "private_nat" {
  route_table_id         = aws_route_table.private.id
  destination_cidr_block = "0.0.0.0/0"
  network_interface_id   = aws_network_interface.nat.id
}

resource "aws_route_table_association" "private" {
  subnet_id      = aws_subnet.private.id
  route_table_id = aws_route_table.private.id
}

# ─── Self-Managed NAT Instance (t4g.nano ARM, IP Masquerading) ───────────────

data "aws_ssm_parameter" "al2023_arm" {
  name = "/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-arm64"
}

resource "aws_network_interface" "nat" {
  subnet_id         = aws_subnet.public.id
  security_groups   = [aws_security_group.nat.id]
  source_dest_check = false

  tags = { Name = "${local.name_prefix}-nat-eni" }
}

resource "aws_eip" "nat" {
  domain            = "vpc"
  network_interface = aws_network_interface.nat.id
  tags              = { Name = "${local.name_prefix}-nat-eip" }
}

resource "aws_instance" "nat" {
  ami           = data.aws_ssm_parameter.al2023_arm.value
  instance_type = "t4g.nano"

  network_interface {
    device_index         = 0
    network_interface_id = aws_network_interface.nat.id
  }

  user_data = <<-SHELL
    #!/bin/bash
    set -euo pipefail

    # Enable IP forwarding
    echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.d/90-nat.conf
    sysctl -p /etc/sysctl.d/90-nat.conf

    # IP masquerading via iptables
    yum install -y iptables-services
    iptables -t nat -A POSTROUTING -o ens5 -s ${var.private_subnet_cidr} -j MASQUERADE
    iptables -A FORWARD -i ens5 -o ens5 -m state --state RELATED,ESTABLISHED -j ACCEPT
    iptables -A FORWARD -i ens5 -o ens5 -j ACCEPT
    service iptables save
    systemctl enable iptables
  SHELL

  tags = {
    Name        = "${local.name_prefix}-nat-instance"
    Environment = "MalwareLab"
  }
}

# ─── Security Groups ────────────────────────────────────────────────────────

# Replace the permissive default SG with deny-all
resource "aws_default_security_group" "deny_all" {
  vpc_id = aws_vpc.lab.id

  # No ingress rules = deny all inbound
  # No egress rules  = deny all outbound

  tags = { Name = "${local.name_prefix}-default-deny-all" }
}

# NAT instance SG – allow private subnet outbound via NAT
resource "aws_security_group" "nat" {
  name_prefix = "${local.name_prefix}-nat-"
  description = "NAT instance: accept from private subnet, forward to internet"
  vpc_id      = aws_vpc.lab.id

  tags = { Name = "${local.name_prefix}-nat-sg" }
}

resource "aws_vpc_security_group_ingress_rule" "nat_from_private" {
  security_group_id = aws_security_group.nat.id
  description       = "All traffic from private subnet"
  cidr_ipv4         = var.private_subnet_cidr
  ip_protocol       = "-1"
}

resource "aws_vpc_security_group_egress_rule" "nat_to_internet_https" {
  security_group_id = aws_security_group.nat.id
  description       = "HTTPS outbound to internet"
  cidr_ipv4         = "0.0.0.0/0"
  from_port         = 443
  to_port           = 443
  ip_protocol       = "tcp"
}

resource "aws_vpc_security_group_egress_rule" "nat_to_internet_http" {
  security_group_id = aws_security_group.nat.id
  description       = "HTTP outbound (package repos)"
  cidr_ipv4         = "0.0.0.0/0"
  from_port         = 80
  to_port           = 80
  ip_protocol       = "tcp"
}

resource "aws_vpc_security_group_egress_rule" "nat_to_internet_dns" {
  security_group_id = aws_security_group.nat.id
  description       = "DNS outbound"
  cidr_ipv4         = "0.0.0.0/0"
  from_port         = 53
  to_port           = 53
  ip_protocol       = "udp"
}

# Detonation-tier SG – explicit outbound only
resource "aws_security_group" "detonation" {
  name_prefix = "${local.name_prefix}-detonation-"
  description = "Detonation tier: deny-all ingress, explicit egress only"
  vpc_id      = aws_vpc.lab.id

  tags = {
    Name        = "${local.name_prefix}-detonation-sg"
    Environment = "MalwareLab"
  }
}

resource "aws_vpc_security_group_egress_rule" "det_https" {
  security_group_id = aws_security_group.detonation.id
  description       = "HTTPS outbound via NAT"
  cidr_ipv4         = "0.0.0.0/0"
  from_port         = 443
  to_port           = 443
  ip_protocol       = "tcp"
}

resource "aws_vpc_security_group_egress_rule" "det_http" {
  security_group_id = aws_security_group.detonation.id
  description       = "HTTP outbound (package repos) via NAT"
  cidr_ipv4         = "0.0.0.0/0"
  from_port         = 80
  to_port           = 80
  ip_protocol       = "tcp"
}

resource "aws_vpc_security_group_egress_rule" "det_dns" {
  security_group_id = aws_security_group.detonation.id
  description       = "DNS outbound"
  cidr_ipv4         = "0.0.0.0/0"
  from_port         = 53
  to_port           = 53
  ip_protocol       = "udp"
}

resource "aws_vpc_security_group_egress_rule" "det_s3_prefix" {
  security_group_id = aws_security_group.detonation.id
  description       = "S3 gateway endpoint (prefix list)"
  prefix_list_id    = aws_vpc_endpoint.s3.prefix_list_id
  ip_protocol       = "tcp"
  from_port         = 443
  to_port           = 443
}

# ─── NACLs ───────────────────────────────────────────────────────────────────

# --- Public Subnet NACL ---

resource "aws_network_acl" "public" {
  vpc_id     = aws_vpc.lab.id
  subnet_ids = [aws_subnet.public.id]
  tags       = { Name = "${local.name_prefix}-public-nacl" }
}

resource "aws_network_acl_rule" "public_deny_blocked_egress" {
  count          = length(var.blocked_cidrs)
  network_acl_id = aws_network_acl.public.id
  rule_number    = 50 + count.index
  egress         = true
  protocol       = "-1"
  rule_action    = "deny"
  cidr_block     = var.blocked_cidrs[count.index]
}

resource "aws_network_acl_rule" "public_allow_https_egress" {
  network_acl_id = aws_network_acl.public.id
  rule_number    = 200
  egress         = true
  protocol       = "tcp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 443
  to_port        = 443
}

resource "aws_network_acl_rule" "public_allow_http_egress" {
  network_acl_id = aws_network_acl.public.id
  rule_number    = 210
  egress         = true
  protocol       = "tcp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 80
  to_port        = 80
}

resource "aws_network_acl_rule" "public_allow_dns_egress" {
  network_acl_id = aws_network_acl.public.id
  rule_number    = 220
  egress         = true
  protocol       = "udp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 53
  to_port        = 53
}

resource "aws_network_acl_rule" "public_allow_ephemeral_egress" {
  network_acl_id = aws_network_acl.public.id
  rule_number    = 300
  egress         = true
  protocol       = "tcp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 32768
  to_port        = 61000
}

# Inbound: allow return traffic on ephemeral ports + internal from private subnet
resource "aws_network_acl_rule" "public_allow_ephemeral_ingress" {
  network_acl_id = aws_network_acl.public.id
  rule_number    = 200
  egress         = false
  protocol       = "tcp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 32768
  to_port        = 61000
}

resource "aws_network_acl_rule" "public_allow_private_ingress" {
  network_acl_id = aws_network_acl.public.id
  rule_number    = 100
  egress         = false
  protocol       = "-1"
  rule_action    = "allow"
  cidr_block     = var.private_subnet_cidr
}

resource "aws_network_acl_rule" "public_allow_dns_return_ingress" {
  network_acl_id = aws_network_acl.public.id
  rule_number    = 210
  egress         = false
  protocol       = "udp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 53
  to_port        = 53
}

# --- Private Subnet NACL ---

resource "aws_network_acl" "private" {
  vpc_id     = aws_vpc.lab.id
  subnet_ids = [aws_subnet.private.id]
  tags       = { Name = "${local.name_prefix}-private-nacl" }
}

resource "aws_network_acl_rule" "private_deny_blocked_egress" {
  count          = length(var.blocked_cidrs)
  network_acl_id = aws_network_acl.private.id
  rule_number    = 50 + count.index
  egress         = true
  protocol       = "-1"
  rule_action    = "deny"
  cidr_block     = var.blocked_cidrs[count.index]
}

resource "aws_network_acl_rule" "private_allow_egress_to_vpc" {
  network_acl_id = aws_network_acl.private.id
  rule_number    = 100
  egress         = true
  protocol       = "-1"
  rule_action    = "allow"
  cidr_block     = var.vpc_cidr
}

resource "aws_network_acl_rule" "private_allow_https_egress" {
  network_acl_id = aws_network_acl.private.id
  rule_number    = 200
  egress         = true
  protocol       = "tcp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 443
  to_port        = 443
}

resource "aws_network_acl_rule" "private_allow_http_egress" {
  network_acl_id = aws_network_acl.private.id
  rule_number    = 210
  egress         = true
  protocol       = "tcp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 80
  to_port        = 80
}

resource "aws_network_acl_rule" "private_allow_dns_egress" {
  network_acl_id = aws_network_acl.private.id
  rule_number    = 220
  egress         = true
  protocol       = "udp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 53
  to_port        = 53
}

resource "aws_network_acl_rule" "private_allow_ephemeral_egress" {
  network_acl_id = aws_network_acl.private.id
  rule_number    = 300
  egress         = true
  protocol       = "tcp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 32768
  to_port        = 61000
}

resource "aws_network_acl_rule" "private_allow_vpc_ingress" {
  network_acl_id = aws_network_acl.private.id
  rule_number    = 100
  egress         = false
  protocol       = "-1"
  rule_action    = "allow"
  cidr_block     = var.vpc_cidr
}

resource "aws_network_acl_rule" "private_allow_ephemeral_ingress" {
  network_acl_id = aws_network_acl.private.id
  rule_number    = 200
  egress         = false
  protocol       = "tcp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 32768
  to_port        = 61000
}

resource "aws_network_acl_rule" "private_allow_dns_return_ingress" {
  network_acl_id = aws_network_acl.private.id
  rule_number    = 210
  egress         = false
  protocol       = "udp"
  rule_action    = "allow"
  cidr_block     = "0.0.0.0/0"
  from_port      = 53
  to_port        = 53
}

# ─── S3 Gateway VPC Endpoint ────────────────────────────────────────────────

resource "aws_vpc_endpoint" "s3" {
  vpc_id       = aws_vpc.lab.id
  service_name = "com.amazonaws.${var.aws_region}.s3"

  route_table_ids = [
    aws_route_table.private.id,
    aws_route_table.public.id,
  ]

  tags = { Name = "${local.name_prefix}-s3-vpce" }
}

# ─── Route 53 Resolver DNS Firewall ─────────────────────────────────────────

resource "aws_route53_resolver_firewall_domain_list" "allowed" {
  name    = "${local.name_prefix}-dns-allow"
  domains = [
    "*.amazonaws.com",
    "*.amazontrust.com",
    "ollama.com",
    "*.ollama.com",
    "github.com",
    "*.github.com",
    "*.githubusercontent.com",
    "huggingface.co",
    "*.huggingface.co",
    "*.hf.co",
    "registry.npmjs.org",
    "pypi.org",
    "*.pypi.org",
    "files.pythonhosted.org",
  ]
}

resource "aws_route53_resolver_firewall_domain_list" "blocked_all" {
  name    = "${local.name_prefix}-dns-block-all"
  domains = ["*"]
}

resource "aws_route53_resolver_firewall_rule_group" "lab" {
  name = "${local.name_prefix}-dns-firewall"
}

resource "aws_route53_resolver_firewall_rule" "allow_list" {
  name                    = "allow-essential"
  firewall_rule_group_id  = aws_route53_resolver_firewall_rule_group.lab.id
  firewall_domain_list_id = aws_route53_resolver_firewall_domain_list.allowed.id
  priority                = 100
  action                  = "ALLOW"
}

resource "aws_route53_resolver_firewall_rule" "block_rest" {
  name                    = "block-everything-else"
  firewall_rule_group_id  = aws_route53_resolver_firewall_rule_group.lab.id
  firewall_domain_list_id = aws_route53_resolver_firewall_domain_list.blocked_all.id
  priority                = 200
  action                  = "BLOCK"
  block_response          = "NXDOMAIN"
}

resource "aws_route53_resolver_firewall_rule_group_association" "lab" {
  name                   = "${local.name_prefix}-dns-fw-assoc"
  firewall_rule_group_id = aws_route53_resolver_firewall_rule_group.lab.id
  vpc_id                 = aws_vpc.lab.id
  priority               = 101
}
